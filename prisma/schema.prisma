generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ─────────────────────────────────────────────────────────────
// USERS & AUTH
// ─────────────────────────────────────────────────────────────

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  password      String?   // For credentials auth
  name          String?
  image         String?
  emailVerified DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Role: can be both artist and reviewer
  isArtist   Boolean @default(false)
  isReviewer Boolean @default(false)

  // How did they hear about us?
  referralSource String?

  // Relations
  artistProfile   ArtistProfile?
  reviewerProfile ReviewerProfile?
  accounts        Account[]
  sessions        Session[]

  passwordResetTokens    PasswordResetToken[]
  emailVerificationTokens EmailVerificationToken[]
  supportTickets         SupportTicket[]
}

// NextAuth required models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  tokenHash String   @unique
  expiresAt DateTime
  usedAt    DateTime?

  createdAt DateTime @default(now())

  @@index([userId, expiresAt])
}

model EmailVerificationToken {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  tokenHash String   @unique
  expiresAt DateTime
  usedAt    DateTime?

  createdAt DateTime @default(now())

  @@index([userId, expiresAt])
}

// ─────────────────────────────────────────────────────────────
// PROFILES
// ─────────────────────────────────────────────────────────────

model ArtistProfile {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  artistName String
  genres     Genre[] @relation("ArtistGenres")

  // Stats
  totalTracks Int @default(0)
  totalSpent  Int @default(0) // in cents

  // Free review credits (new users get 1)
  freeReviewCredits Int @default(1)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tracks Track[]
}

model ReviewerProfile {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Tier system
  tier ReviewerTier @default(NORMAL)

  // Stats
  totalReviews   Int   @default(0)
  averageRating  Float @default(0)
  totalEarnings  Int   @default(0) // in cents
  pendingBalance Int   @default(0) // in cents, not yet withdrawn

  // Genre expertise
  genres Genre[] @relation("ReviewerGenres")

  // Linked accounts for taste verification
  spotifyId      String?
  lastfmUsername String?

  stripeAccountId String? @unique

  stripeConnectedAt DateTime?

  country String?

  onboardingQuizScore      Int      @default(0)
  onboardingQuizPassed     Boolean  @default(false)
  onboardingQuizCompletedAt DateTime?

  // Quality flags
  gemCount       Int     @default(0)
  flagCount      Int     @default(0)
  isRestricted   Boolean @default(false)
  completedOnboarding Boolean @default(false)

  // Daily limits
  reviewsToday     Int      @default(0)
  lastReviewDate   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  reviews      Review[]
  queueEntries ReviewQueue[]
  payouts      Payout[]

  @@index([lastReviewDate])
}

enum ReviewerTier {
  NORMAL
  PRO
}

// ─────────────────────────────────────────────────────────────
// GENRES
// ─────────────────────────────────────────────────────────────

model Genre {
  id   String @id @default(cuid())
  name String @unique
  slug String @unique

  artistProfiles   ArtistProfile[]   @relation("ArtistGenres")
  reviewerProfiles ReviewerProfile[] @relation("ReviewerGenres")
  tracks           Track[]           @relation("TrackGenres")
}

// ─────────────────────────────────────────────────────────────
// TRACKS
// ─────────────────────────────────────────────────────────────

model Track {
  id       String @id @default(cuid())
  artistId String
  artist   ArtistProfile @relation(fields: [artistId], references: [id], onDelete: Cascade)

  // Source info
  sourceUrl  String
  sourceType TrackSource
  title      String
  artworkUrl String?
  duration   Int? // in seconds
  bpm        Int? // beats per minute

  // Categorization
  genres Genre[] @relation("TrackGenres")

  // Optional guidance
  feedbackFocus String? // "Looking for feedback on the mix" etc.

  // Submission status
  status TrackStatus @default(PENDING_PAYMENT)

  // Package info
  packageType      PackageType
  reviewsRequested Int
  reviewsCompleted Int         @default(0)

  // Promo tracking
  promoCode String? // Which promo code was used (null if paid normally)

  // Timestamps
  createdAt           DateTime  @default(now())
  paidAt              DateTime?
  completedAt         DateTime?
  linkIssueNotifiedAt DateTime? // When admin notified artist about broken link

  // Relations
  payment      Payment?
  reviews      Review[]
  queueEntries ReviewQueue[]

  @@index([status, createdAt])
  @@index([artistId])
  @@index([paidAt])
}

enum TrackSource {
  SOUNDCLOUD
  BANDCAMP
  YOUTUBE
  UPLOAD
}

enum TrackStatus {
  PENDING_PAYMENT
  QUEUED      // Paid, waiting for reviewers
  IN_PROGRESS // Some reviews complete
  COMPLETED   // All reviews done
  CANCELLED
}

enum PackageType {
  STARTER   // 5 reviews, mixed
  STANDARD  // 10 reviews, verified+
  PRO       // 10 reviews, pro only
  DEEP_DIVE // 25 reviews, mixed + 3 Pro
}

// ─────────────────────────────────────────────────────────────
// REVIEWS
// ─────────────────────────────────────────────────────────────

model Review {
  id         String          @id @default(cuid())
  trackId    String
  track      Track           @relation(fields: [trackId], references: [id], onDelete: Cascade)
  reviewerId String
  reviewer   ReviewerProfile @relation(fields: [reviewerId], references: [id], onDelete: Cascade)

  status ReviewStatus @default(ASSIGNED)

  // Listen tracking
  listenDuration Int @default(0) // seconds actually listened
  lastHeartbeat  DateTime?

  // Structured feedback
  firstImpression  FirstImpression?
  productionScore  Int? // 1-5
  vocalScore       Int? // 1-5 (nullable for instrumentals)
  originalityScore Int? // 1-5
  wouldListenAgain Boolean?

  // Listener signals - quick engagement indicators
  wouldAddToPlaylist Boolean?
  wouldShare         Boolean?
  wouldFollow        Boolean?

  // Genre/artist matching
  perceivedGenre String?
  similarArtists String? // comma-separated

  // Qualitative feedback
  bestPart          String?
  bestPartTimestamp Int?    // seconds
  weakestPart       String?
  weakestTimestamp  Int?    // seconds
  additionalNotes   String?

  addressedArtistNote AddressedArtistNote?
  nextActions         String?
  timestamps          Json?

  // Earnings
  paidAmount Int @default(0) // cents

  // Quality tracking
  artistRating Int?     // 1-5, set by artist
  isGem        Boolean  @default(false)
  wasFlagged   Boolean  @default(false)
  flagReason   String?

  // Sharing
  shareId String? @unique // Short unique ID for public sharing

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([trackId, reviewerId])
  @@index([reviewerId, status])
  @@index([trackId])
  @@index([status])
}

enum ReviewStatus {
  ASSIGNED    // Reviewer assigned, not started
  IN_PROGRESS // Listening/reviewing
  COMPLETED   // Submitted
  EXPIRED     // Timed out, reassigned
  SKIPPED     // Reviewer skipped
}

enum AddressedArtistNote {
  YES
  PARTIALLY
  NO
}

enum SupportTicketStatus {
  OPEN
  NEEDS_INFO
  RESOLVED
  CLOSED
}

enum SupportMessageAuthorType {
  USER
  ADMIN
}

model SupportTicket {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  subject String
  status  SupportTicketStatus @default(OPEN)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  messages SupportMessage[]

  @@index([userId, createdAt])
  @@index([status, updatedAt])
}

model SupportMessage {
  id       String @id @default(cuid())
  ticketId String
  ticket   SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  authorType  SupportMessageAuthorType
  authorUserId String?
  authorEmail  String?

  body String

  createdAt DateTime @default(now())

  @@index([ticketId, createdAt])
}

enum FirstImpression {
  STRONG_HOOK
  DECENT
  LOST_INTEREST
}

// ─────────────────────────────────────────────────────────────
// PAYMENTS
// ─────────────────────────────────────────────────────────────

model Payment {
  id      String @id @default(cuid())
  trackId String @unique
  track   Track  @relation(fields: [trackId], references: [id], onDelete: Cascade)

  amount           Int    // cents
  stripeSessionId  String @unique
  stripePaymentId  String?
  status           PaymentStatus @default(PENDING)

  createdAt   DateTime  @default(now())
  completedAt DateTime?
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

model Payout {
  id         String          @id @default(cuid())
  reviewerId String
  reviewer   ReviewerProfile @relation(fields: [reviewerId], references: [id])

  amount Int          // cents
  method PayoutMethod
  status PayoutStatus

  // External reference
  externalId String? // PayPal transaction ID, Stripe transfer ID, etc.

  createdAt   DateTime  @default(now())
  processedAt DateTime?
}

enum PayoutMethod {
  PAYPAL
  STRIPE_CONNECT
  MANUAL
}

enum PayoutStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

// ─────────────────────────────────────────────────────────────
// QUEUE MANAGEMENT
// ─────────────────────────────────────────────────────────────

model ReviewQueue {
  id         String          @id @default(cuid())
  trackId    String
  track      Track           @relation(fields: [trackId], references: [id], onDelete: Cascade)
  reviewerId String
  reviewer   ReviewerProfile @relation(fields: [reviewerId], references: [id], onDelete: Cascade)

  priority   Int      @default(0) // Higher = more urgent
  assignedAt DateTime @default(now())
  expiresAt  DateTime // Auto-reassign if not completed

  @@unique([trackId, reviewerId])
  @@index([reviewerId, expiresAt])
}

model RateLimit {
  id      String   @id
  count   Int      @default(0)
  resetAt DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([resetAt])
}

model StripeWebhookEvent {
  id        String   @id
  type      String
  expiresAt DateTime

  createdAt DateTime @default(now())

  @@index([expiresAt])
}
