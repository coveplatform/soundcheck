generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ─────────────────────────────────────────────────────────────
// USERS & AUTH
// ─────────────────────────────────────────────────────────────

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  password      String?   // For credentials auth
  name          String?
  image         String?
  emailVerified DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Role: can be both artist and reviewer
  isArtist   Boolean @default(false)
  isReviewer Boolean @default(false)

  // How did they hear about us?
  referralSource String?

  // Re-engagement tracking
  trialReminderSentAt DateTime?

  // Relations
  artistProfile   ArtistProfile?
  listenerProfile ListenerProfile?
  accounts        Account[]
  sessions        Session[]

  passwordResetTokens    PasswordResetToken[]
  emailVerificationTokens EmailVerificationToken[]
  supportTickets         SupportTicket[]

  // Affiliate system
  createdAffiliateLinks TrackAffiliateLink[] @relation("CreatedAffiliateLinks")
  affiliateCommissions  ExternalPurchase[]   @relation("AffiliateCommissions")
}

// NextAuth required models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  tokenHash String   @unique
  expiresAt DateTime
  usedAt    DateTime?

  createdAt DateTime @default(now())

  @@index([userId, expiresAt])
}

model EmailVerificationToken {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  tokenHash String   @unique
  expiresAt DateTime
  usedAt    DateTime?

  createdAt DateTime @default(now())

  @@index([userId, expiresAt])
}

// ─────────────────────────────────────────────────────────────
// PROFILES
// ─────────────────────────────────────────────────────────────

model ArtistProfile {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  artistName String
  genres     Genre[] @relation("ArtistGenres")

  // Stats
  totalTracks Int @default(0)
  totalSpent  Int @default(0) // in cents

  freeReviewCredits Int @default(1)

  // Earnings from track purchases
  pendingBalance Int @default(0) // in cents, available to withdraw
  totalEarnings  Int @default(0) // in cents, lifetime earnings

  // Subscription (for unlimited uploads)
  stripeCustomerId        String?   // Stripe customer ID for subscriptions
  subscriptionStatus      String?   // active, canceled, past_due, etc.
  subscriptionId          String?   // Stripe subscription ID
  subscriptionTier        String?   // pro (for now just one tier)
  subscriptionCurrentPeriodEnd DateTime? // When current period ends
  subscriptionCanceledAt  DateTime? // When they canceled (still active until period end)

  // Stripe Connect for payouts
  stripeAccountId   String?   @unique
  stripeConnectedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tracks Track[]
}

model ListenerProfile {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Tier system
  tier ReviewerTier @default(NORMAL)

  // Stats
  totalReviews   Int   @default(0)
  averageRating  Float @default(0)
  totalEarnings  Int   @default(0) // in cents
  pendingBalance Int   @default(0) // in cents, not yet withdrawn

  // Genre expertise
  genres Genre[] @relation("ReviewerGenres")

  // Linked accounts for taste verification
  spotifyId      String?
  lastfmUsername String?

  stripeAccountId String? @unique

  stripeConnectedAt DateTime?

  country String?

  onboardingQuizScore      Int      @default(0)
  onboardingQuizPassed     Boolean  @default(false)
  onboardingQuizCompletedAt DateTime?

  // Quality flags
  gemCount       Int     @default(0)
  flagCount      Int     @default(0)
  isRestricted   Boolean @default(false)
  completedOnboarding Boolean @default(false)

  // Daily limits
  reviewsToday     Int      @default(0)
  lastReviewDate   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  reviews      Review[]
  queueEntries ReviewQueue[]
  payouts      Payout[]
  purchases    Purchase[] @relation("PurchasesByReviewer")

  // Affiliate system
  referralPurchases Purchase[] @relation("ReferralPurchases")
  affiliateEarnings Int        @default(0) // cents earned from referrals

  @@index([lastReviewDate])
  @@map("ReviewerProfile")
}

enum ReviewerTier {
  NORMAL
  PRO
}

// ─────────────────────────────────────────────────────────────
// GENRES
// ─────────────────────────────────────────────────────────────

model Genre {
  id   String @id @default(cuid())
  name String @unique
  slug String @unique

  artistProfiles   ArtistProfile[]   @relation("ArtistGenres")
  listenerProfiles ListenerProfile[] @relation("ReviewerGenres")
  tracks           Track[]           @relation("TrackGenres")
}

// ─────────────────────────────────────────────────────────────
// TRACKS
// ─────────────────────────────────────────────────────────────

model Track {
  id       String @id @default(cuid())
  artistId String
  artist   ArtistProfile @relation(fields: [artistId], references: [id], onDelete: Cascade)

  // Source info
  sourceUrl  String
  sourceType TrackSource
  title      String
  artworkUrl String?
  duration   Int? // in seconds
  bpm        Int? // beats per minute

  // Categorization
  genres Genre[] @relation("TrackGenres")

  // Optional guidance
  feedbackFocus String? // "Looking for feedback on the mix" etc.

  // Visibility
  isPublic Boolean @default(false)

  // Purchase settings (only for UPLOAD tracks)
  allowPurchase Boolean @default(false) // Artist opt-in to allow reviewers to buy

  // Public sharing & sales (NEW - for affiliate/monetization system)
  trackShareId    String?      @unique // Short ID for public links e.g., `/t/[trackShareId]`
  sharingEnabled  Boolean      @default(false) // Whether public sharing is enabled
  sharingMode     SharingMode? // EXPOSURE or SALES
  salePrice       Int?         // cents (e.g., 500 = $5.00), null if not for sale
  showReviewsOnPublicPage Boolean @default(true) // Show reviews on public share page
  publicPlayCount Int @default(0) // Plays from public share page

  // Submission status
  status TrackStatus @default(PENDING_PAYMENT)

  // Package info
  packageType      PackageType
  reviewsRequested Int
  reviewsCompleted Int         @default(0)

  // Promo tracking
  promoCode String? // Which promo code was used (null if paid normally)

  // Timestamps
  createdAt           DateTime  @default(now())
  paidAt              DateTime?
  completedAt         DateTime?
  linkIssueNotifiedAt DateTime? // When admin notified artist about broken link

  // View tracking
  viewCount    Int       @default(0) // Total views for public tracks
  lastViewedAt DateTime? // When track was last viewed

  // Stem support
  hasStems Boolean @default(false)
  stems    TrackStem[]

  // Ableton project support
  abletonProjectUrl    String? // S3 URL to uploaded project ZIP
  abletonProjectData   Json?   // Parsed project metadata (tempo, tracks, plugins, etc.)
  abletonRenderStatus  AbletonRenderStatus? // Status of cloud rendering

  // Relations
  payment      Payment?
  reviews      Review[]
  queueEntries ReviewQueue[]
  purchases    Purchase[]
  externalPurchases ExternalPurchase[]
  affiliateLinks    TrackAffiliateLink[]

  @@index([status, createdAt])
  @@index([artistId])
  @@index([paidAt])
  @@index([abletonRenderStatus])
}

enum AbletonRenderStatus {
  PENDING     // Project uploaded, waiting to render
  RENDERING   // Cloud instance is rendering stems
  COMPLETED   // Stems rendered and stored
  FAILED      // Rendering failed
}

enum TrackSource {
  SOUNDCLOUD
  BANDCAMP
  YOUTUBE
  UPLOAD
}

enum TrackStatus {
  UPLOADED
  PENDING_PAYMENT
  QUEUED      // Paid, waiting for reviewers
  IN_PROGRESS // Some reviews complete
  COMPLETED   // All reviews done
  CANCELLED
}

enum PackageType {
  STARTER   // 5 reviews, mixed
  STANDARD  // 10 reviews, verified+
  PRO       // 10 reviews, pro only
  DEEP_DIVE // 25 reviews, mixed + 3 Pro
}

enum SharingMode {
  EXPOSURE // Free streaming/plays, track engagement
  SALES    // Paid downloads with revenue split
}

// ─────────────────────────────────────────────────────────────
// TRACK STEMS
// ─────────────────────────────────────────────────────────────

model TrackStem {
  id       String   @id @default(cuid())
  trackId  String
  track    Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)

  // Storage
  stemUrl  String // S3 URL or local path

  // Metadata
  stemType StemType
  label    String   // User-provided name (e.g., "Lead Vocals", "Kick Drum")
  order    Int      // Display order in mixer (0 = first)
  duration Int?     // Seconds (for validation)

  // Processing metadata (optional, for future features)
  waveformData Json? // Pre-computed waveform peaks

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([trackId, order])
  @@index([trackId])
}

enum StemType {
  MASTER  // Full mix (always present for stem uploads)
  DRUMS   // All percussion
  BASS    // Bass instruments
  SYNTHS  // Synthesizers, keys
  VOCALS  // All vocals (lead + backing)
  MELODY  // Melodic instruments (guitar, piano, etc.)
  FX      // Effects, atmospheres
  OTHER   // Custom/other
}

// ─────────────────────────────────────────────────────────────
// REVIEWS
// ─────────────────────────────────────────────────────────────

model Review {
  id         String          @id @default(cuid())
  trackId    String
  track      Track           @relation(fields: [trackId], references: [id], onDelete: Cascade)
  reviewerId String
  reviewer   ListenerProfile @relation(fields: [reviewerId], references: [id], onDelete: Cascade)

  status ReviewStatus @default(ASSIGNED)

  reviewSchemaVersion Int     @default(1)
  countsTowardCompletion Boolean @default(true)
  countsTowardAnalytics  Boolean @default(true)

  // Listen tracking
  listenDuration Int @default(0) // seconds actually listened
  lastHeartbeat  DateTime?

  // Structured feedback
  firstImpression  FirstImpression?
  productionScore  Int? // 1-5
  vocalScore       Int? // 1-5 (nullable for instrumentals)
  originalityScore Int? // 1-5
  wouldListenAgain Boolean?

  // Listener signals - quick engagement indicators
  wouldAddToPlaylist Boolean?
  wouldShare         Boolean?
  wouldFollow        Boolean?

  // Genre/artist matching
  perceivedGenre String?
  similarArtists String? // comma-separated

  // Qualitative feedback
  bestPart          String?
  bestPartTimestamp Int?    // seconds
  weakestPart       String?
  weakestTimestamp  Int?    // seconds
  additionalNotes   String?

  addressedArtistNote AddressedArtistNote?
  nextActions         String?
  timestamps          Json?

  timestampNotes ReviewTimestamp[]

  // Earnings
  paidAmount Int @default(0) // cents

  // Quality tracking
  artistRating Int?     // 1-5, set by artist
  isGem        Boolean  @default(false)
  wasFlagged   Boolean  @default(false)
  flagReason   String?

  // Sharing
  shareId String? @unique // Short unique ID for public sharing

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([trackId, reviewerId])
  @@index([reviewerId, status])
  @@index([trackId])
  @@index([status])
}

model ReviewTimestamp {
  id       String @id @default(cuid())
  reviewId String
  review   Review  @relation(fields: [reviewId], references: [id], onDelete: Cascade)

  seconds Int
  note    String

  createdAt DateTime @default(now())

  @@index([reviewId])
  @@index([reviewId, seconds])
}

enum ReviewStatus {
  ASSIGNED    // Reviewer assigned, not started
  IN_PROGRESS // Listening/reviewing
  COMPLETED   // Submitted
  EXPIRED     // Timed out, reassigned
  SKIPPED     // Reviewer skipped
}

enum AddressedArtistNote {
  YES
  PARTIALLY
  NO
}

enum SupportTicketStatus {
  OPEN
  NEEDS_INFO
  RESOLVED
  CLOSED
}

enum SupportMessageAuthorType {
  USER
  ADMIN
}

model SupportTicket {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  subject String
  status  SupportTicketStatus @default(OPEN)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  messages SupportMessage[]

  @@index([userId, createdAt])
  @@index([status, updatedAt])
}

model SupportMessage {
  id       String @id @default(cuid())
  ticketId String
  ticket   SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  authorType  SupportMessageAuthorType
  authorUserId String?
  authorEmail  String?

  body String

  createdAt DateTime @default(now())

  @@index([ticketId, createdAt])
}

enum FirstImpression {
  STRONG_HOOK
  DECENT
  LOST_INTEREST
}

// ─────────────────────────────────────────────────────────────
// PAYMENTS
// ─────────────────────────────────────────────────────────────

model Payment {
  id      String @id @default(cuid())
  trackId String @unique
  track   Track  @relation(fields: [trackId], references: [id], onDelete: Cascade)

  amount           Int    // cents
  stripeSessionId  String @unique
  stripePaymentId  String?
  status           PaymentStatus @default(PENDING)

  createdAt   DateTime  @default(now())
  completedAt DateTime?
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

model Payout {
  id         String          @id @default(cuid())
  reviewerId String
  reviewer   ListenerProfile @relation(fields: [reviewerId], references: [id])

  amount Int          // cents
  method PayoutMethod
  status PayoutStatus

  // External reference
  externalId String? // PayPal transaction ID, Stripe transfer ID, etc.

  createdAt   DateTime  @default(now())
  processedAt DateTime?
}

enum PayoutMethod {
  PAYPAL
  STRIPE_CONNECT
  MANUAL
}

enum PayoutStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

// Track purchases by reviewers
model Purchase {
  id         String          @id @default(cuid())
  trackId    String
  track      Track           @relation(fields: [trackId], references: [id], onDelete: Cascade)
  reviewerId String
  reviewer   ListenerProfile @relation("PurchasesByReviewer", fields: [reviewerId], references: [id], onDelete: Cascade)

  amount    Int      // cents (50 = $0.50)
  createdAt DateTime @default(now())

  // Referral tracking for affiliate commission
  referredByReviewerId String?
  referredBy           ListenerProfile? @relation("ReferralPurchases", fields: [referredByReviewerId], references: [id], onDelete: SetNull)
  referralShareId      String?
  commissionPaid       Int              @default(0) // cents paid as commission

  @@unique([trackId, reviewerId]) // One purchase per reviewer per track
  @@index([reviewerId])
  @@index([trackId])
  @@index([referredByReviewerId])
}

// External track purchases by public users (not reviewers)
model ExternalPurchase {
  id      String @id @default(cuid())
  trackId String
  track   Track  @relation(fields: [trackId], references: [id], onDelete: Cascade)

  // Buyer info (not a registered user, just email)
  buyerEmail String
  buyerName  String?

  // Payment via Stripe
  amount                 Int     // cents (full sale price, e.g., 500 for $5)
  stripePaymentIntentId  String  @unique
  stripeCheckoutSessionId String?
  status                 ExternalPurchaseStatus @default(PENDING)

  // Revenue split
  platformFee         Int // cents kept by platform (e.g., 20% = 100¢)
  affiliateCommission Int @default(0) // cents to affiliate (e.g., 10% = 50¢)
  artistAmount        Int // cents to artist (e.g., 70% = 350¢)

  // Affiliate tracking
  affiliateCode   String? // which campaign link was used
  affiliateUserId String? // who gets the commission (artist or other)
  affiliateUser   User?   @relation("AffiliateCommissions", fields: [affiliateUserId], references: [id], onDelete: SetNull)

  // Download delivery
  downloadUrl   String? // S3 pre-signed URL (expires after 7 days)
  downloadedAt  DateTime?
  downloadCount Int       @default(0)

  createdAt   DateTime  @default(now())
  completedAt DateTime?

  @@index([trackId])
  @@index([affiliateCode])
  @@index([buyerEmail])
  @@index([affiliateUserId])
  @@index([status])
}

enum ExternalPurchaseStatus {
  PENDING   // Checkout created, not paid
  COMPLETED // Payment successful
  FAILED    // Payment failed
  REFUNDED  // Purchase refunded
}

// Track affiliate link management for campaigns
model TrackAffiliateLink {
  id      String @id @default(cuid())
  trackId String
  track   Track  @relation(fields: [trackId], references: [id], onDelete: Cascade)

  code String @unique // e.g., "twitter_jan" for `/t/[trackShareId]?ref=twitter_jan`
  name String // Campaign name (e.g., "Twitter January Campaign")

  // Who created this link (usually the artist)
  createdByUserId String
  createdByUser   User   @relation("CreatedAffiliateLinks", fields: [createdByUserId], references: [id], onDelete: Cascade)

  // Performance stats
  clickCount    Int @default(0)
  playCount     Int @default(0)
  purchaseCount Int @default(0)
  totalRevenue  Int @default(0) // cents earned from this link

  isActive Boolean @default(true) // Can be deactivated

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([trackId])
  @@index([code])
  @@index([createdByUserId])
}

// ─────────────────────────────────────────────────────────────
// QUEUE MANAGEMENT
// ─────────────────────────────────────────────────────────────

model ReviewQueue {
  id        String @id @default(cuid())
  trackId   String
  track     Track  @relation(fields: [trackId], references: [id], onDelete: Cascade)
  reviewerId String
  reviewer   ListenerProfile @relation(fields: [reviewerId], references: [id], onDelete: Cascade)

  priority   Int      @default(0) // Higher = more urgent
  assignedAt DateTime @default(now())
  expiresAt  DateTime // Auto-reassign if not completed

  @@unique([trackId, reviewerId])
  @@index([reviewerId, expiresAt])
}

model RateLimit {
  id      String   @id
  count   Int      @default(0)
  resetAt DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([resetAt])
}

model StripeWebhookEvent {
  id        String   @id
  type      String
  expiresAt DateTime

  createdAt DateTime @default(now())

  @@index([expiresAt])
}

// Lead capture for users who aren't ready to submit
model LeadCapture {
  id        String   @id @default(cuid())
  email     String
  artistName String?
  source    String   @default("get-feedback") // where they signed up
  reminded  Boolean  @default(false)
  converted Boolean  @default(false) // did they come back and submit?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([email])
  @@index([reminded, createdAt])
}
